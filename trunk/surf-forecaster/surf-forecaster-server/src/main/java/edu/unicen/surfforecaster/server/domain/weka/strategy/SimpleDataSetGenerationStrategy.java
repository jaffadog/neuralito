package edu.unicen.surfforecaster.server.domain.weka.strategy;

import java.io.Serializable;
import java.sql.Time;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.List;
import java.util.Map;
import java.util.Vector;

import weka.core.Instance;
import weka.core.Instances;
import edu.unicen.surfforecaster.common.services.dto.Unit;
import edu.unicen.surfforecaster.common.services.dto.WaveWatchParameter;
import edu.unicen.surfforecaster.server.domain.entity.Forecast;
import edu.unicen.surfforecaster.server.domain.entity.Point;
import edu.unicen.surfforecaster.server.domain.entity.VisualObservation;
import edu.unicen.surfforecaster.server.domain.wavewatch.WaveWatchSystem;
import edu.unicen.surfforecaster.server.domain.weka.filter.AndFilter;
import edu.unicen.surfforecaster.server.domain.weka.filter.Filter;
import edu.unicen.surfforecaster.server.domain.weka.filter.wavewatch.ForecastDayLightFilter;
import edu.unicen.surfforecaster.server.domain.weka.filter.wavewatch.ForecastMaxWaveHeightFilter;
import edu.unicen.surfforecaster.server.domain.weka.util.Util;

/**
 * 
 * @author esteban
 * 
 */
public class SimpleDataSetGenerationStrategy implements
		DataSetGenerationStrategy {
	/**
	 * Auto-Generated serialVersionUID.
	 */
	private static final long serialVersionUID = 6625411909943252625L;
	/**
	 * The name of the data set containing the instances generated by this
	 * strategy.
	 */
	private static String dataSetName = "SimpleDataSet";
	/**
	 * The attribute which is set as class attribute.
	 */
	private static String classAttributeName = "visualObservation";
	/**
	 * The attributes which compose the instances generated by this strategy.
	 */
	private static String[] strategyAttributes = new String[] { "ww3Direction",
			"ww3Period", "ww3Height", "visualObservation" };
	/**
	 * The options this strategy allows.
	 */
	private static Map<String, OptionType> options = new HashMap<String, OptionType>() {
		{
			put("latitudeGridPoint1", OptionType.DECIMAL);
			put("longitudeGridPoint1", OptionType.DECIMAL);
			put("utcSunriseHour", OptionType.INTEGER);
			put("utcSunriseMinute", OptionType.INTEGER);
			put("utcSunsetHour", OptionType.INTEGER);
			put("utcSunsetMinute", OptionType.INTEGER);
		}
	};

	@Override
	public Map<Forecast, Instance> generateLatestForecastInstances(
			final WaveWatchSystem model, final Map<String, Serializable> options) {
		final Map<Forecast, Instance> generatedInstances = new HashMap<Forecast, Instance>();
		final Point gridPoint = getGridPoint(options);
		final List<Forecast> latestForecasts = model.getForecasts(gridPoint);
		for (final Forecast forecast : latestForecasts) {
			final Map<String, Double> instanceData = generateInstanceData(
					forecast, new VisualObservation(0D, new Date(),
							Unit.Degrees));
			final Instance instance = Util.createWekaInstance(instanceData,
					strategyAttributes, classAttributeName);
			generatedInstances.put(forecast, instance);
		}
		return generatedInstances;
	}

	@Override
	public Instances generateTrainningInstances(final WaveWatchSystem model,
			final Collection<VisualObservation> observations,
			final Map<String, Serializable> options) {
		final Point gridPoint = getGridPoint(options);
		final Time sunrise = getSunrise(options);
		final Time sunset = getSunset(options);
		final Date from = oldestObservation(observations);
		final Date to = mostRecentObservation(observations);
		final Collection<Forecast> archivedForecasts = model
				.getArchivedForecasts(gridPoint, from, to);
		// For each day filter the forecast with greatest wave height which
		// occur during daylight.
		final Collection<Forecast> filteredForecasts = filterForecasts(
				archivedForecasts, sunrise, sunset);
		// Util.printCollection(filteredForecasts);
		final Collection<Map<String, Double>> instancesData = new Vector<Map<String, Double>>();
		// For each forecast, couple it with the corresponding visual
		// observation to generate the instance.
		for (final Forecast forecast : filteredForecasts) {
			for (final VisualObservation observation : observations) {
				if (observation.equalsDate(forecast.getForecastValidDate())) {
					instancesData.add(generateInstanceData(forecast,
							observation));
					break;
				}
			}
		}
		final Instances instances = Util.createWekaInstances(dataSetName,
				instancesData, strategyAttributes, classAttributeName);
		return instances;
	}

	@Override
	public Map<String, OptionType> listAvailableOptions() {
		return options;
	}

	/**
	 * Filter forecasts using 2 filters: 1)Filter those forecasts which occur
	 * during daylight. 2)Filter the forecasts which has the max wave height
	 * during each day.
	 * 
	 * @param forecasts
	 *            to be filtered
	 * @param sunrise
	 *            the time the daylight begins
	 * @param sunset
	 *            the time the daylight ends
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private Collection<Forecast> filterForecasts(
			Collection<Forecast> forecasts, final Time sunrise,
			final Time sunset) {
		final Vector<Filter> filters = new Vector<Filter>();
		final Filter dataTimeFilter = new ForecastDayLightFilter(sunrise,
				sunset);
		filters.add(dataTimeFilter);
		filters.add(new ForecastMaxWaveHeightFilter());
		final Filter compuestFilter = new AndFilter(filters);
		forecasts = (Vector<Forecast>) compuestFilter.executeFilter(new Vector(
				forecasts));
		return forecasts;
	}

	/**
	 * 
	 * Creates a map <AttributeName,AttributeValue> containing the data of an
	 * instance.
	 * 
	 * @param forecast
	 *            to obtain forecast related attributes
	 * @param observation
	 *            to obtain observation attribute
	 * @return
	 */
	private Hashtable<String, Double> generateInstanceData(
			final Forecast forecast, final VisualObservation observation) {
		final Hashtable<String, Double> instanceData = new Hashtable<String, Double>();
		instanceData.put("ww3Direction", (double) forecast.getParameter(
				WaveWatchParameter.PRIMARY_WAVE_DIRECTION_V2.getValue())
				.getfValue());
		instanceData.put("ww3Period", (double) forecast.getParameter(
				WaveWatchParameter.PRIMARY_WAVE_PERIOD_V2.getValue())
				.getfValue());
		instanceData.put("ww3Height", (double) forecast.getParameter(
				WaveWatchParameter.COMBINED_SWELL_WIND_WAVE_HEIGHT_V2
						.getValue()).getfValue());
		if (observation != null) {
			instanceData.put("visualObservation", observation.getWaveHeight());
		}
		return instanceData;
	}

	/**
	 * Obtain grid point from options.
	 * 
	 * @param options
	 * @return
	 */
	private Point getGridPoint(final Map<String, Serializable> options) {

		final Float latitude = (Float) options.get("latitudeGridPoint1");
		final Float longitude = (Float) options.get("longitudeGridPoint1");
		return new Point(latitude, longitude);
	}

	/**
	 * Obtain the most recent visual observation date.
	 * 
	 * @param observations
	 * @return
	 */
	private Date mostRecentObservation(
			final Collection<VisualObservation> observations) {
		long mostRecentDate = Long.MIN_VALUE;
		for (final VisualObservation observation : observations) {
			if (observation.getDate().getTime() > mostRecentDate) {
				mostRecentDate = observation.getDate().getTime();
			}
		}
		return new Date(mostRecentDate);
	}

	/**
	 * Obtain the oldest visual observation date.
	 * 
	 * @param observations
	 * @return
	 */
	private Date oldestObservation(
			final Collection<VisualObservation> observations) {
		long oldestDate = Long.MAX_VALUE;
		for (final VisualObservation observation : observations) {
			if (observation.getDate().getTime() < oldestDate) {
				oldestDate = observation.getDate().getTime();
			}
		}
		return new Date(oldestDate);
	}

	/**
	 * Obtain the sunset time from the options.
	 * 
	 * @param options
	 * @return
	 */
	private Time getSunset(final Map<String, Serializable> options) {
		final int sunsetHour = (Integer) options.get("utcSunsetHour");
		final int sunsetMinute = (Integer) options.get("utcSunsetMinute");
		final Time sunset = new Time(sunsetHour, sunsetMinute, 0);
		return sunset;
	}

	/**
	 * Obtain the sunrise time from the options.
	 * 
	 * @param options
	 * @return
	 */
	private Time getSunrise(final Map<String, Serializable> options) {
		final int sunriseHour = (Integer) options.get("utcSunriseHour");
		final int sunriseMinute = (Integer) options.get("utcSunriseMinute");
		final Time sunrise = new Time(sunriseHour, sunriseMinute, 0);
		return sunrise;
	}

}
