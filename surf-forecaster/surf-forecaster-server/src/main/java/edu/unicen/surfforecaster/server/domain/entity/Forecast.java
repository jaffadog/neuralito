/**
 * 
 */
package edu.unicen.surfforecaster.server.domain.entity;

import java.util.Calendar;
import java.util.Collection;
import java.util.Date;
import java.util.GregorianCalendar;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Set;
import java.util.TimeZone;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import org.apache.commons.lang.Validate;

import edu.unicen.surfforecaster.common.services.dto.ForecastAttributeDTO;
import edu.unicen.surfforecaster.common.services.dto.ForecastDTO;
import edu.unicen.surfforecaster.common.services.dto.WaveWatchParameter;
import edu.unicen.surfforecaster.server.domain.weka.util.Util;

/**
 * @author esteban
 * 
 */
@Entity
public class Forecast implements Comparable<Forecast> {
	/**
	 * Entity autogenerated id.
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer id;
	/**
	 * The base date of this forecast.This is the date the forecast was made.
	 */
	private Date issuedDate;

	/**
	 * The time ahead base date to which this forecast applies. This corresponds
	 * to Hours since the baseDate.
	 */
	private Integer forecastTime;

	/**
	 * Map with <parameterName, parameterValue> info. Parameters may be:
	 * waveHeight, wavePeriod, waveDirection, windSpeed.
	 */
	@OneToMany(cascade = CascadeType.ALL)
	@MapKey(name = "parameterName")
	private Map<String, ForecastValue> parameters;

	/**
	 * The location this forecast belongs.
	 */
	@OneToOne(cascade = CascadeType.ALL)
	private Point point;

	/**
	 * Default Constructor.
	 */
	public Forecast() {
		// ORM purpose.
	}

	/**
	 * @param baseDate
	 * @param runDate
	 * @param forecastDate
	 * @param parameters
	 * @param point2
	 * @param ww3Forecaster
	 */
	public Forecast(final Date baseDate, final Integer forecastTime,
			final Point point2, final Map<String, ForecastValue> parameters) {
		Validate.notNull(baseDate);
		Validate.notNull(parameters);
		issuedDate = baseDate;
		this.forecastTime = forecastTime;
		this.parameters = parameters;
		point = point2;
	}

	/**
	 * @return the id
	 */
	public Integer getId() {
		return id;
	}

	/**
	 * @return the attributes this forecast has.
	 */
	public ForecastValue getParameter(final String parameterName) {
		return parameters.get(parameterName);
	}

	/**
	 * @return the baseDate
	 */
	public Date getBaseDate() {
		return issuedDate;
	}

	/**
	 * @return forecastTime which is the hours ahead the baseDate for which this
	 *         forecast belongs.
	 */
	public Integer getForecastTime() {
		return forecastTime;
	}

	public Date getForecastValidDate() {
		final long minutes = getForecastTime() * 60;
		final long seconds = minutes * 60;
		final long milliseconds = seconds * 1000;
		return new Date(getBaseDate().getTime() + milliseconds);
	}

	/**
	 * @return
	 */
	public ForecastDTO getDTO(final TimeZone timeZone) {
		final Collection<String> keys = parameters.keySet();
		final Map<String, ForecastAttributeDTO> map = new HashMap<String, ForecastAttributeDTO>();
		for (final Iterator iterator = keys.iterator(); iterator.hasNext();) {
			final String key = (String) iterator.next();
			map.put(key, parameters.get(key).getDTO());
		}
		final Calendar cal = new GregorianCalendar(timeZone);
		cal.setTime(getBaseDate());

		final Calendar cal2 = new GregorianCalendar(timeZone);
		cal2.setTime(getForecastValidDate());

		return new ForecastDTO(cal, getForecastTime(), cal2, map);
	}

	/**
	 * @return
	 */
	public Point getPoint() {
		return point;
	}

	public Date getForecastDate() {
		final long hoursInMillis = forecastTime * 60 * 60 * 1000;
		return new Date(issuedDate.getTime() + hoursInMillis);
	}

	public void addParameter(final String name, final ForecastValue parameter) {
		parameters.put(name, parameter);
	}

	public Set<String> getParameters() {
		return parameters.keySet();
	}

	public boolean equalsDate(final Date date) {
		final Calendar cal = new GregorianCalendar();
		final Calendar cal2 = new GregorianCalendar();
		cal2.setTime(date);
		cal.setTime(getForecastValidDate());
		if (cal.get(Calendar.YEAR) == cal2.get(Calendar.YEAR))
			if (cal.get(Calendar.MONTH) == cal2.get(Calendar.MONTH))
				if (cal.get(Calendar.DAY_OF_MONTH) == cal2
						.get(Calendar.DAY_OF_MONTH))
					return true;
		return false;
	}

	@Override
	public int compareTo(final Forecast o) {
		final Forecast ww3Data = o;
		final int result = getForecastValidDate().compareTo(
				ww3Data.getForecastValidDate());

		if (result < 0)
			return -1;
		if (result > 0)
			return 1;

		return 0;
	}

	@Override
	public String toString() {
		// TODO Auto-generated method stub
		return "WW3: "
				+ Util.getDateFormatter().format(getForecastValidDate())
				+ " WvH:"
				+ Util
						.getDecimalFormatter()
						.format(
								parameters
										.get(
												WaveWatchParameter.COMBINED_SWELL_WIND_WAVE_HEIGHT_V2
														.getValue())
										.getfValue())
				+ " WvP:"
				+ Util.getDecimalFormatter().format(
						parameters.get(
								WaveWatchParameter.PRIMARY_WAVE_PERIOD_V2
										.getValue()).getfValue())
				+ " WvD:"
				+ Util.getDecimalFormatter().format(
						parameters.get(
								WaveWatchParameter.PRIMARY_WAVE_DIRECTION_V2
										.getValue()).getfValue());
		// + " WnD:"
		// + Util.getDecimalFormatter().format(
		// this.calculateWindDirection(windU, windV)) + "WnS:"
		// + Util.getDecimalFormatter().format(this.windSpeed) + "WnU:"
		// + Util.getDecimalFormatter().format(this.windU) + "WnV:"
		// + Util.getDecimalFormatter().format(this.windV);
	}

}
