package edu.unicen.surfforecaster.server.domain.weka.strategy;

import java.io.Serializable;
import java.sql.Time;
import java.util.Arrays;
import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Hashtable;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Set;
import java.util.Vector;

import weka.core.Instance;
import weka.core.Instances;
import edu.unicen.surfforecaster.common.services.dto.Unit;
import edu.unicen.surfforecaster.common.services.dto.WaveWatchParameter;
import edu.unicen.surfforecaster.server.domain.entity.Forecast;
import edu.unicen.surfforecaster.server.domain.entity.Point;
import edu.unicen.surfforecaster.server.domain.entity.VisualObservation;
import edu.unicen.surfforecaster.server.domain.wavewatch.WaveWatchSystem;
import edu.unicen.surfforecaster.server.domain.weka.filter.AndFilter;
import edu.unicen.surfforecaster.server.domain.weka.filter.Filter;
import edu.unicen.surfforecaster.server.domain.weka.filter.wavewatch.ForecastDayLightFilter;
import edu.unicen.surfforecaster.server.domain.weka.filter.wavewatch.ForecastMaxWaveHeightFilter;
import edu.unicen.surfforecaster.server.domain.weka.util.Util;

public class WW3LastNLecturesStrategy implements DataSetGenerationStrategy {
	private String strategyString;
	private final String shortDescription;
	private Integer lastNLectures = 3;
	/**
	 * The name of the data set containing the instances generated by this
	 * strategy.
	 */
	private static String dataSetName = "LastNLectures";
	/**
	 * The attribute which is set as class attribute.
	 */
	private static String classAttributeName = "visualObservation";
	/**
	 * The attributes which compose the instances generated by this strategy.
	 */
	private static String[] strategyAttributes = new String[] {};

	/**
	 * 
	 */
	public WW3LastNLecturesStrategy() {
		shortDescription = "";
	}

	/**
	 * The options this strategy allows.
	 */
	private static Map<String, OptionType> options = new HashMap<String, OptionType>() {
		{
			put("latitudeGridPoint1", OptionType.DECIMAL);
			put("longitudeGridPoint1", OptionType.DECIMAL);
			put("utcSunriseHour", OptionType.INTEGER);
			put("utcSunriseMinute", OptionType.INTEGER);
			put("utcSunsetHour", OptionType.INTEGER);
			put("utcSunsetMinute", OptionType.INTEGER);
		}
	};

	public String getShortDescription() {
		return shortDescription;
	}

	public WW3LastNLecturesStrategy(final String beach, final String[] years,
			final double ww3Y, final double ww3X) {
		shortDescription = "strategy[NLecturesStrategy ].beach[" + beach
				+ "].years " + Arrays.toString(years)
				+ ".months[1-12].height[unrestriced].ww3.1[" + ww3Y + ","
				+ ww3X + "]";
	}

	@Override
	public String toString() {
		return strategyString;
	}

	/**
	 * @param ww3Data
	 * @param j
	 * @return
	 */
	private Forecast[] getWWData(final Forecast ww3Data,
			final List<Forecast> waveWatchData, final int j) {
		final Forecast[] previousLecture = new Forecast[j + 1];

		for (int i = 0; i < waveWatchData.size(); i++) {
			final Forecast array_element = waveWatchData.get(i);
			if (array_element.getForecastValidDate().equals(
					ww3Data.getForecastValidDate())) {
				previousLecture[0] = ww3Data;
				for (int k = 1; k <= j; k++) {
					if (i - k >= 0) {
						if (waveWatchData.get(i - k).getForecastValidDate()
								.getTime() == array_element
								.getForecastValidDate().getTime()
								- 10800000 * k) {
							// System.out.println("FOUND EQ k :" + k);
							previousLecture[k] = waveWatchData.get(i - k);
						} else {
							previousLecture[k] = null;
						}

					} else {
						previousLecture[k] = null;
					}
				}
				break;
			}

		}
		return previousLecture;
	}

	@Override
	public Instances generateTrainningInstances(final WaveWatchSystem model,
			final Collection<VisualObservation> obsDataSet,
			final Map<String, Serializable> options) {
		final Point gridPoint = getGridPoint(options);
		final Time sunrise = getSunrise(options);
		final Time sunset = getSunset(options);
		final Date from = oldestObservation(obsDataSet);
		final Date to = mostRecentObservation(obsDataSet);
		final List<Forecast> archivedForecasts = model.getArchivedForecasts(
				gridPoint, from, to);
		// For each day filter the forecast with greatest wave height which
		// occur during daylight.
		final Collection<Forecast> filteredForecasts = filterForecasts(
				archivedForecasts, sunrise, sunset);
		// Util.printCollection(filteredForecasts);
		final Collection<Map<String, Double>> instancesData = new Vector<Map<String, Double>>();
		for (final Forecast forecast : filteredForecasts) {

			final Forecast ww3Data = forecast;

			VisualObservation obsData = null;
			for (final VisualObservation observation : obsDataSet) {

				final VisualObservation fObsData = observation;
				if (fObsData.equalsDate(ww3Data.getForecastValidDate())) {
					obsData = fObsData;
					final Hashtable<String, Double> generateInstanceData = generateInstanceData(
							ww3Data, archivedForecasts, fObsData, lastNLectures);
					if (generateInstanceData != null) {
						instancesData.add(generateInstanceData);
					}
					break;
				}
			}

		}

		final Instances instances = Util.createWekaInstances(dataSetName,
				instancesData, strategyAttributes, classAttributeName);
		// Util.printWekaInstances(instances);
		return instances;

	}

	/**
	 * 
	 * Creates a map <AttributeName,AttributeValue> containing the data of an
	 * instance.
	 * 
	 * @param forecast
	 *            to obtain forecast related attributes
	 * @param observation
	 *            to obtain observation attribute
	 * @return
	 */
	private Hashtable<String, Double> generateInstanceData(
			final Forecast ww3Data, final List<Forecast> waveWatchData,
			final VisualObservation obsData, final Integer previousLectures) {
		final Hashtable<String, Double> data = new Hashtable<String, Double>();
		data.put("ww3Height", (double) ww3Data.getParameter(
				WaveWatchParameter.COMBINED_SWELL_WIND_WAVE_HEIGHT_V2
						.getValue()).getfValue());
		data.put("ww3Period", (double) ww3Data.getParameter(
				WaveWatchParameter.PRIMARY_WAVE_PERIOD_V2.getValue())
				.getfValue());
		data.put("ww3Direction", (double) ww3Data.getParameter(
				WaveWatchParameter.PRIMARY_WAVE_DIRECTION_V2.getValue())
				.getfValue());

		final Forecast[] prevLectures = getWWData(ww3Data, waveWatchData,
				previousLectures);
		boolean allPreviousLectureFound = true;
		for (int j = 1; j <= previousLectures; j++) {
			if (prevLectures[j] == null) {
				allPreviousLectureFound = false;

			} else {
				data
						.put(
								"ww3HeightPrevLect" + j,
								(double) prevLectures[j]
										.getParameter(
												WaveWatchParameter.COMBINED_SWELL_WIND_WAVE_HEIGHT_V2
														.getValue())
										.getfValue());
				data.put("ww3PeriodPrevLect" + j, (double) prevLectures[j]
						.getParameter(
								WaveWatchParameter.PRIMARY_WAVE_PERIOD_V2
										.getValue()).getfValue());
				data.put("ww3DirectPrevLect" + j, (double) prevLectures[j]
						.getParameter(
								WaveWatchParameter.PRIMARY_WAVE_DIRECTION_V2
										.getValue()).getfValue());
			}
		}
		if (allPreviousLectureFound) {

			data.put("visualObservation", obsData.getWaveHeight());

			if (strategyAttributes.length == 0) {
				final Set<String> attributes = data.keySet();
				strategyAttributes = new String[attributes.size()];
				final Iterator<String> it = attributes.iterator();
				int j = 0;
				while (it.hasNext()) {
					final String attribute = it.next();
					if (!attribute.equals("visualObservation")) {
						strategyAttributes[j] = attribute;
						j++;
					}
				}
				// Visual observation is the class attribute and should
				// be
				// the last in the list.
				strategyAttributes[j] = "visualObservation";
			}
			return data;
		} else
			return null;

	}

	/**
	 * Filter forecasts using 2 filters: 1)Filter those forecasts which occur
	 * during daylight. 2)Filter the forecasts which has the max wave height
	 * during each day.
	 * 
	 * @param forecasts
	 *            to be filtered
	 * @param sunrise
	 *            the time the daylight begins
	 * @param sunset
	 *            the time the daylight ends
	 * @return
	 */
	@SuppressWarnings("unchecked")
	private Collection<Forecast> filterForecasts(
			Collection<Forecast> forecasts, final Time sunrise,
			final Time sunset) {
		final Vector<Filter> filters = new Vector<Filter>();
		final Filter dataTimeFilter = new ForecastDayLightFilter(sunrise,
				sunset);
		filters.add(dataTimeFilter);
		filters.add(new ForecastMaxWaveHeightFilter());
		final Filter compuestFilter = new AndFilter(filters);
		forecasts = (Vector<Forecast>) compuestFilter.executeFilter(new Vector(
				forecasts));
		return forecasts;
	}

	/**
	 * Obtain grid point from options.
	 * 
	 * @param options
	 * @return
	 */
	private Point getGridPoint(final Map<String, Serializable> options) {

		final Float latitude = (Float) options.get("latitudeGridPoint1");
		final Float longitude = (Float) options.get("longitudeGridPoint1");
		return new Point(latitude, longitude);
	}

	/**
	 * Obtain the most recent visual observation date.
	 * 
	 * @param observations
	 * @return
	 */
	private Date mostRecentObservation(
			final Collection<VisualObservation> observations) {
		long mostRecentDate = Long.MIN_VALUE;
		for (final VisualObservation observation : observations) {
			if (observation.getDate().getTime() > mostRecentDate) {
				mostRecentDate = observation.getDate().getTime();
			}
		}
		return new Date(mostRecentDate);
	}

	/**
	 * Obtain the oldest visual observation date.
	 * 
	 * @param observations
	 * @return
	 */
	private Date oldestObservation(
			final Collection<VisualObservation> observations) {
		long oldestDate = Long.MAX_VALUE;
		for (final VisualObservation observation : observations) {
			if (observation.getDate().getTime() < oldestDate) {
				oldestDate = observation.getDate().getTime();
			}
		}
		return new Date(oldestDate);
	}

	/**
	 * Obtain the sunset time from the options.
	 * 
	 * @param options
	 * @return
	 */
	private Time getSunset(final Map<String, Serializable> options) {
		final int sunsetHour = (Integer) options.get("utcSunsetHour");
		final int sunsetMinute = (Integer) options.get("utcSunsetMinute");
		final Time sunset = new Time(sunsetHour, sunsetMinute, 0);
		return sunset;
	}

	/**
	 * Obtain the sunrise time from the options.
	 * 
	 * @param options
	 * @return
	 */
	private Time getSunrise(final Map<String, Serializable> options) {
		final int sunriseHour = (Integer) options.get("utcSunriseHour");
		final int sunriseMinute = (Integer) options.get("utcSunriseMinute");
		final Time sunrise = new Time(sunriseHour, sunriseMinute, 0);
		return sunrise;
	}

	/**
	 * @see edu.unicen.surfforecaster.server.domain.weka.strategy.DataSetGenerationStrategy#generateLatestForecastInstances(edu.unicen.surfforecaster.server.domain.wavewatch.WaveWatchSystem,
	 *      java.util.Map)
	 */
	@Override
	public Map<Forecast, Instance> generateLatestForecastInstances(
			final WaveWatchSystem model, final Map<String, Serializable> options) {
		final Map<Forecast, Instance> generatedInstances = new HashMap<Forecast, Instance>();
		final Point gridPoint = getGridPoint(options);
		final List<Forecast> latestForecasts = model.getForecasts(gridPoint);
		final Date oneDayPrevious = new Date(model.getLatestForecastTime()
				.getTime()
				- 48 * 60 * 60 * 1000);
		final List<Forecast> lastNLecturesForecasts = model
				.getArchivedForecasts(gridPoint, oneDayPrevious, new Date());
		lastNLecturesForecasts.addAll(latestForecasts);
		for (final Forecast forecast : latestForecasts) {
			final Map<String, Double> instanceData = generateInstanceData(
					forecast, lastNLecturesForecasts, new VisualObservation(0D,
							new Date(), Unit.Degrees), lastNLectures);
			// If we could generate an instance with the supplied data we add it
			// to result.
			if (instanceData != null) {
				final Instance instance = Util.createWekaInstance(instanceData,
						strategyAttributes, classAttributeName);
				generatedInstances.put(forecast, instance);
			}

		}
		return generatedInstances;
	}

	/**
	 * @see edu.unicen.surfforecaster.server.domain.weka.strategy.DataSetGenerationStrategy#listAvailableOptions()
	 */
	@Override
	public Map<String, OptionType> listAvailableOptions() {
		// TODO Auto-generated method stub
		return options;
	}

	/**
	 * @param lastNLectures
	 *            the lastNLectures to set
	 */
	public void setLastNLectures(final Integer lastNLectures) {
		this.lastNLectures = lastNLectures;
	}

}
