/**
 * 
 */
package edu.unicen.surfforecaster.server.domain.entity.forecaster;

import java.util.Collection;
import java.util.Date;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;

import javax.persistence.CascadeType;
import javax.persistence.Entity;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.MapKey;
import javax.persistence.OneToMany;
import javax.persistence.OneToOne;

import org.apache.commons.lang.Validate;

import edu.unicen.surfforecaster.common.services.dto.ForecastAttributeDTO;
import edu.unicen.surfforecaster.common.services.dto.ForecastDTO;

/**
 * @author esteban
 * 
 */
@Entity
public class Forecast {
	/**
	 * Entity autogenerated id.
	 */
	@Id
	@GeneratedValue(strategy = GenerationType.AUTO)
	private Integer id;
	/**
	 * The base date of this forecast.
	 */
	private Date issuedDate;
	/**
	 * The date to which this forecast applies. This corresponds to Hours since
	 * the baseDate.
	 */
	private Integer forecastTime;
	/**
	 * Map with <parameterName, parameterValue> info. Parameters may be:
	 * waveHeight, wavePeriod, waveDirection, windSpeed.
	 */
	@OneToMany(cascade = CascadeType.ALL, fetch = FetchType.EAGER)
	@MapKey(name = "parameterName")
	private Map<String, ForecastParameter> parameters;

	/**
	 * The location this forecast belongs.
	 */
	@OneToOne(cascade = CascadeType.ALL)
	private Point point;

	/**
	 * Default Constructor.
	 */
	public Forecast() {
		// ORM purpose.
	}

	/**
	 * @param baseDate
	 * @param runDate
	 * @param forecastDate
	 * @param parameters
	 * @param point2
	 * @param ww3Forecaster
	 */
	public Forecast(final Date baseDate, final Integer forecastTime,
			final Map<String, ForecastParameter> parameters, final Point point2) {
		Validate.notNull(baseDate);
		Validate.notNull(parameters);
		issuedDate = baseDate;
		this.forecastTime = forecastTime;
		this.parameters = parameters;
		point = point2;
	}

	/**
	 * @return the id
	 */
	public Integer getId() {
		return id;
	}

	/**
	 * @return the attributes this forecast has.
	 */
	public ForecastParameter getParameter(final String parameterName) {
		return parameters.get(parameterName);
	}

	/**
	 * @return the baseDate
	 */
	public Date getBaseDate() {
		return issuedDate;
	}

	/**
	 * @return forecastTime which is the hours ahead the baseDate for which this
	 *         forecast belongs.
	 */
	public Integer getForecastTime() {
		return forecastTime;
	}

	/**
	 * @return
	 */
	public ForecastDTO getDTO() {
		final Collection<ForecastParameter> values = parameters.values();
		final Map<String, ForecastAttributeDTO> map = new HashMap<String, ForecastAttributeDTO>();
		for (final Iterator iterator = values.iterator(); iterator.hasNext();) {
			final ForecastParameter forecastParameter = (ForecastParameter) iterator
					.next();
			map.put(forecastParameter.getParameterName(), forecastParameter
					.getDTO());
		}
		return new ForecastDTO(getBaseDate(), getForecastTime(), map);
	}

	/**
	 * @return
	 */
	public Point getPoint() {
		return point;
	}

}
